<!--
author: 刘青
date: 2016-09-13
title: 自动加载原理
tags: 
category: php/composer
status: publish
summary:  
-->
### 初窥
使用Composer可以将Packagist中的包下载到本地的 `vendor` 目录中。还有一项非常重要的功能，它可以自动加载类。在PHP中，所有的类的加载之前一定要引入文件，不然会报错。我们看看Composer是如何实现的。

在 `vendor` 目录下一个autoload.php 文件，在项目的最开始的地方引入它就可以实现自动加载的功能。我们看看里面的代码：
```
require_once __DIR__ . '/composer' . '/autoload_real.php';

return ComposerAutoloaderInite7bbc9e18f4d13c4675486b0c8f56260::getLoader();
```

它把目标指向了composer 文件夹，我们看一眼该文件夹：
```
.
├── autoload.php
├── composer
│   ├── autoload_classmap.php
│   ├── autoload_namespaces.php
│   ├── autoload_psr4.php
│   ├── autoload_real.php
│   ├── autoload_static.php
│   ├── ClassLoader.php
│   ├── installed.json
│   └── LICENSE
```

所有的自动加载的实现都在这里了。

### 理论知识
#### PHP的加载机制
不像Java等高级语言通过命名空间就可以直接使用类，PHP使用前必须先将文件引入进来，不然会报错。当类因为没有引入包含该类的文件时PHP会调用[`spl_autoload_register`](http://php.net/manual/zh/function.spl-autoload-register.php)函数来做最后一次尝试。
我们做个小实验：
```
// 创建 Foo 类，放在 a/b/c/Foo.php 中
<?php 
namespace a\b\c;

class Foo
{
    public function say()
    {
        echo "I am Here";
    }
}

//创建一个index.php
<?php
$foo = new a\b\c\Foo();
$foo->say();
//=> PHP Fatal error:  Class 'a\b\c\Foo' not found in /home/liuqing/composer/index.php on line 3

//方式1：在最前面引入php文件 index_require.php
<?php
require(__DIR__ . '/a/b/c/Foo.php');
$foo = new a\b\c\Foo();
$foo->say(); //=> I am here

//方式2：使用sql_autoload_register index_register.php
<?php
spl_autoload_register("autoload");

function autoload($class_name, $file_extensions) {
    echo $class_name . "\n" . $file_extensions . "\n";

    require(__DIR__ . '/a/b/c/Foo.php');
}

$foo = new \a\b\c\Foo();
$foo->say();

/**
a\b\c\Foo

I am Here 
*/
```

上面的代码说明了PHP的加载机制了。Composer的自动加载就是基于这个的。
我们自己分析一下，如果要我们自己实现这个，应该是什么的逻辑呢？对，所有的文章都应该在index.register.php 的`autoload`函数。要是类名和文件之间有规律可循，我们岂不是可以任何时候根据类名来引入文件？

#### [PSR1](http://www.php-fig.org/psr/psr-1)中[自动加载](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md)规范
**强制要求**
- 有效的命名空间和类名必须遵循结构： \<Vendor Name>\(Namespace\)*<Class Name>
- 每个命名空间必须有顶级命名空间（Vendor Name）
- 每个命名空间可以有它自己希望的子命名空间
- 在将类从文件系统中加载时每个`命名空间分隔符`在加载时转换为`目录分隔符`
- 类名中的 `_` 被转换为 `目录分隔符`，命名空间中的 `_` 没有特殊含义
- 有效的命名空间和类在从文件系统加载时以 `.php` 为后缀
- vendor名，命名空间，类名有任意大小写字母组合组成

注：命名空间分隔符是 \， 目录分隔符是 /

举例子说明吧：
- \System\Lib\StringUtil => /path to project/Project/lib/vendor/System/Lib/StringUtil.php
- \System\Lib\Util_Math  => /path to project/Porject/lib/vendor/System/Lib/Util/Math.php

####
[PSR4](http://www.php-fig.org/psr/psr-4) 规范

PSR1的建议过时了，但它依旧是使用最广的编码规范。PSR4 是新的自动加载的规范,严格的说是对PSR1的补充。
PSR4描述了从文件路径自动加载到类的规范。

1. 名词 `类` 包括 类、接口、traits和其他相似的结构。
2. 完整的类名遵循的格式： \<NamespaceName>(\SubNamespaceNaems)*\<ClassName>
    1. 完整的类名必须有顶级命名空间，也就是 vendor 命名空间
    2. 完整的类名可能有一到多个子命名空间
    3. 完整的类名有一个终结的类名
    4. 下划线没有特殊的含义子完整的列名的任意部分
    5. 完整的类名由任意的大小写字母组成
    6. 类名必须大小写敏感
3. 根据完整类名加载文件
    1.
    完整的类名中前面的连续的命名空间和子命名空间，不包括命名空间分隔符（`命名空间前缀`）对于至少一个 `基准目录`
    2. `命名空间前缀`后面的连续的子命名空间对应 `基准目录`中的子目录，命名空间中的分隔符代表目录的分隔符。子目录必须匹配子命名空间的大小写
    3. 最终的类名对于的文件以 `.php` 结尾。文件名必须匹配类名的大小写
4. 自动加载钱的实现必须不抛异常和任何等级的错误，不应该有返回值

例子：
|完整类名|命名空间前缀|基准目录|完整文件名|
| ------ | ----  | ---- | ---- |
| \Acme\Log\Writer\File_Writer | Acme\Log\Writer |  ./acme-log-writer/lib/ | ./acme-log-writer/lib/File_Writer.php | 
| \Aura\Web\Respose\Status | Aura\Web | /path/to/aura-web/src/| /path/to/aura-web/src/Response/Status.php |
| \Zend\Acl | Zend | /usr/includes/Zend/ | /use/includes/Zend/Acl.php |

#### Composer 的实现
好了，我们开始看Composer的实现。在vendor目录下有一个 autoload.php 的文件
```
<?php
// autoload.php @generated by Composer
require_once __DIR__ . '/composer' . '/autoload_real.php';
return ComposerAutoloaderInite7bbc9e18f4d13c4675486b0c8f56260::getLoader();
```
所有的内容都在composer/autoload_real.php中。composer这个包一定会存在vendor目录下，它负责类的自动加载。
```
public static function getLoader()
{
    //静态变量，初始化只做一次
    if (null !== self::$loader) {
        return self::$loader;
    }

    //下面的类名就是本类的类名，后面会放上本类的loadClassLoader，就是加载自身
    spl_autoload_register(array('ComposerAutoloaderInite7bbc9e18f4d13c4675486b0c8f56260', 'loadClassLoader'), true, true);
    self::$loader = $loader = new \Composer\Autoload\ClassLoader();
    //自身加载完了，就移除它，因为以后都不会再加载自身了

```
